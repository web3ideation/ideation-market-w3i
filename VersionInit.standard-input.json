{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "evmVersion": "paris",
    "libraries": {},
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode"
        ]
      }
    }
  },
  "sources": {
    "src/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @notice Listing snapshot stored under a unique `listingId`.\n/// @dev `feeRate` is captured at listing time (denominator = 100_000). `erc1155Quantity`\n/// uses the convention: `0` for ERC-721 listings, `>0` for ERC-1155 (must be \u22651).\nstruct Listing {\n    /// @notice Unique listing identifier.\n    uint128 listingId;\n    /// @notice Marketplace fee rate at the time of listing.\n    /// @dev Denominator is 100_000 (e.g., 1_000 = 1%). Stored to make fees stable across updates.\n    uint32 feeRate;\n    /// @notice If true, only whitelisted buyers may purchase this listing.\n    bool buyerWhitelistEnabled;\n    /// @notice If true and ERC-1155, allows partial purchases (per-unit price must divide evenly).\n    bool partialBuyEnabled;\n    // 38 bytes padding for future tiny vars\n    /// @notice NFT contract being sold (ERC-721 or ERC-1155).\n    address tokenAddress;\n    /// @notice Token id within `tokenAddress`.\n    uint256 tokenId;\n    /// @notice Quantity listed when selling ERC-1155; must be 0 for ERC-721.\n    uint256 erc1155Quantity;\n    /// @notice Total listing price in wei (for ERC-1155: total for all `erc1155Quantity` units).\n    uint256 price;\n    /// @notice Holder address captured at listing time.\n    address seller;\n    /// @notice Optional desired NFT contract for swap listings (address(0) means no swap).\n    address desiredTokenAddress;\n    /// @notice Desired token id (swap only).\n    uint256 desiredTokenId;\n    /// @notice Desired ERC-1155 quantity for swap (0 for ERC-721 swap or non-swap).\n    uint256 desiredErc1155Quantity;\n}\n\n/// @notice Application-level storage shared by all facets.\n/// @dev Lives at `APP_STORAGE_POSITION` and is accessed via `LibAppStorage.appStorage()`.\nstruct AppStorage {\n    /// @notice Monotonic counter for new listing ids.\n    uint128 listingIdCounter;\n    /// @notice Marketplace fee rate (denominator 100_000; e.g., 1_000 = 1%).\n    /// @dev Used as the default/current fee; listings snapshot this into `Listing.feeRate`.\n    uint32 innovationFee;\n    /// @notice Max number of addresses accepted per buyer whitelist batch (Verified stability at 300).\n    uint16 buyerWhitelistMaxBatchSize;\n    /// @notice Simple boolean reentrancy lock.\n    bool reentrancyLock;\n    // 9\u00a0bytes padding for future tiny vars\n    /// @notice Primary listing registry by id.\n    mapping(uint128 listingId => Listing listing) listings;\n    /// @notice Reverse index: NFT (contract,id) \u2192 active listing ids.\n    mapping(address tokenContract => mapping(uint256 tokenId => uint128[] listingIds)) tokenToListingIds;\n    /// @notice ETH proceeds available to withdraw by address (sellers, fee collector, royalty receivers, buyers\u2019 change).\n    mapping(address seller => uint256 amount) proceeds;\n    /// @notice Collection whitelist flags set by the Diamond Owner to curate Utility Token Contracts.\n    mapping(address collection => bool isWhitelisted) whitelistedCollections;\n    /// @notice Iterable list of whitelisted collections.\n    address[] whitelistedCollectionsArray;\n    /// @notice Index helper for `whitelistedCollectionsArray`.\n    mapping(address collection => uint256 index) whitelistedCollectionsIndex;\n    /// @notice Per-listing buyer whitelist set by the listing seller.\n    mapping(uint128 listingId => mapping(address buyer => bool isWhitelisted)) whitelistedBuyersByListingId;\n    /// @notice Example upgrade variable to demonstrate adding new storage via a facet upgrade.\n    /// @dev Appended at the end to preserve storage layout of existing fields.\n    uint256 marketVersion;\n}\n\n/// @title LibAppStorage\n/// @notice Canonical application storage for the IdeationMarket diamond (separate from LibDiamond storage).\n/// @dev All marketplace facets `delegatecall` into the diamond and must read/write this struct via `appStorage()`.\n/// Upgrade rule: append new fields only; never reorder/remove existing fields to avoid storage collisions.\nlibrary LibAppStorage {\n    /// @notice Canonical storage slot for `AppStorage`.\n    /// @dev keccak256(\"diamond.standard.app.storage\").\n    bytes32 constant APP_STORAGE_POSITION = keccak256(\"diamond.standard.app.storage\");\n\n    /// @notice Returns a pointer to `AppStorage` at the canonical slot.\n    /// @dev Inline assembly assigns the slot to the returned storage reference.\n    function appStorage() internal pure returns (AppStorage storage s) {\n        bytes32 appStoragePosition = APP_STORAGE_POSITION;\n        assembly {\n            s.slot := appStoragePosition\n        }\n    }\n}\n"
    },
    "src/upgradeInitializers/VersionInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {LibAppStorage, AppStorage} from \"../libraries/LibAppStorage.sol\";\n\n/// @title VersionInit\n/// @notice Simple initializer used during diamondCut to set the initial `marketVersion`.\n/// @dev Executed via `delegatecall` from the diamond, so it writes into the diamond's storage.\ncontract VersionInit {\n    function init(uint256 initialVersion) external {\n        AppStorage storage s = LibAppStorage.appStorage();\n        s.marketVersion = initialVersion;\n    }\n}\n"
    }
  }
}