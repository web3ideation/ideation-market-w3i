{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "evmVersion": "paris",
    "libraries": {},
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode"
        ]
      }
    }
  },
  "sources": {
    "src/facets/IdeationMarketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"../libraries/LibAppStorage.sol\";\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC165.sol\";\nimport \"../interfaces/IERC2981.sol\";\nimport \"../interfaces/IERC1155.sol\";\nimport \"../interfaces/IBuyerWhitelistFacet.sol\";\n\nerror IdeationMarket__NotApprovedForMarketplace();\nerror IdeationMarket__AlreadyListed();\nerror IdeationMarket__SellerNotTokenOwner(uint128 listingId);\nerror IdeationMarket__NotAuthorizedOperator();\nerror IdeationMarket__ListingTermsChanged();\nerror IdeationMarket__FreeListingsNotSupported();\nerror IdeationMarket__PriceNotMet(uint128 listingId, uint256 price, uint256 value);\nerror IdeationMarket__SameBuyerAsSeller();\nerror IdeationMarket__NoSwapForSameToken();\nerror IdeationMarket__NotSupportedTokenStandard();\nerror IdeationMarket__NotListed();\nerror IdeationMarket__Reentrant();\nerror IdeationMarket__CollectionNotWhitelisted(address tokenAddress);\nerror IdeationMarket__BuyerNotWhitelisted(uint128 listingId, address buyer);\nerror IdeationMarket__InvalidNoSwapParameters();\nerror IdeationMarket__SellerInsufficientTokenBalance(uint256 required, uint256 available);\nerror IdeationMarket__RoyaltyFeeExceedsProceeds();\nerror IdeationMarket__NotAuthorizedToCancel();\nerror IdeationMarket__InsufficientSwapTokenBalance(uint256 required, uint256 available);\nerror IdeationMarket__WhitelistDisabled();\nerror IdeationMarket__WrongErc1155HolderParameter();\nerror IdeationMarket__WrongQuantityParameter();\nerror IdeationMarket__StillApproved();\nerror IdeationMarket__PartialBuyNotPossible();\nerror IdeationMarket__InvalidPurchaseQuantity();\nerror IdeationMarket__InvalidUnitPrice();\nerror IdeationMarket__CurrencyNotAllowed();\nerror IdeationMarket__WrongPaymentCurrency();\nerror IdeationMarket__EthTransferFailed(address receiver);\nerror IdeationMarket__ERC20TransferFailed(address token, address receiver);\nerror IdeationMarket__ContractPaused();\n\n/// @title IdeationMarketFacet\n/// @notice Core marketplace logic: create/update/cancel/purchase listings, optional buyer whitelists, swaps, partial buys, and fee/royalty accounting.\n/// @dev Shared state via `LibAppStorage.AppStorage`. Key invariants & behaviors:\n/// - Fee denominator is 100_000 (e.g., 1_000 = 1%). Each listing snapshots the fee into `Listing.feeRate`.\n/// - Collection whitelist gates listing updates and purchases; de-whitelisting blocks buys and is cleaned via `cleanListing`.\n/// - ERC-1155 vs ERC-721: `erc1155Quantity == 0` \u21d2 ERC-721, `> 0` \u21d2 ERC-1155. Partial buys only for ERC-1155 and require `price % quantity == 0`.\n/// - Swaps: the buyer transfers a specified NFT to the seller during purchase; same-token swaps are disallowed.\n/// - Royalties (ERC-2981) are deducted from seller proceeds and transferred directly to the royalty receiver during purchase.\n/// - Payments are distributed atomically in order: marketplace owner (innovation fee) \u2192 seller (proceeds minus fees/royalties) \u2192 royalty receiver (if any). All transfers happen immediately during purchase.\n/// - ETH purchases require exact msg.value (no overpayment). ERC-20 purchases use buyer's approval for direct transfers to recipients (diamond never holds tokens).\n/// - Reentrancy guard: single boolean `reentrancyLock` flip-flop in storage.\ncontract IdeationMarketFacet {\n    /**\n     * @notice Emitted when an item is listed on the marketplace.\n     * @param listingId The listing ID.\n     * @param tokenAddress The address of the NFT contract.\n     * @param tokenId The token ID being listed.\n     * @param price Listing price.\n     * @param currency Payment currency (address(0) = ETH, otherwise ERC-20 token address).\n     * @param seller The address of the seller.\n     * @param desiredTokenAddress The desired NFT address for swaps (0 for non-swap listing).\n     * @param desiredTokenId The desired token ID for swaps (only applicable for swap listing).\n     * @param feeRate innovationFee rate at the time of listing in case it gets updated before selling.\n     * @param erc1155Quantity Quantity (for ERC1155 tokens; must be 0 for ERC721).\n     */\n    event ListingCreated(\n        uint128 indexed listingId,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        uint256 erc1155Quantity,\n        uint256 price,\n        address currency,\n        uint32 feeRate,\n        address seller,\n        bool buyerWhitelistEnabled,\n        bool partialBuyEnabled,\n        address desiredTokenAddress,\n        uint256 desiredTokenId,\n        uint256 desiredErc1155Quantity\n    );\n\n    event ListingPurchased(\n        uint128 indexed listingId,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        uint256 erc1155Quantity,\n        bool partialBuy,\n        uint256 price,\n        address currency,\n        uint32 feeRate,\n        address seller,\n        address buyer,\n        address desiredTokenAddress,\n        uint256 desiredTokenId,\n        uint256 desiredErc1155Quantity\n    );\n\n    event ListingCanceled(\n        uint128 indexed listingId,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        address seller,\n        address triggeredBy\n    );\n\n    event ListingUpdated(\n        uint128 indexed listingId,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        uint256 erc1155Quantity,\n        uint256 price,\n        address currency,\n        uint32 feeRate,\n        address seller,\n        bool buyerWhitelistEnabled,\n        bool partialBuyEnabled,\n        address desiredTokenAddress,\n        uint256 desiredTokenId,\n        uint256 desiredErc1155Quantity\n    );\n\n    event InnovationFeeUpdated(uint32 previousFee, uint32 newFee);\n\n    event ListingCanceledDueToInvalidListing(\n        uint128 indexed listingId,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        address seller,\n        address triggeredBy\n    );\n\n    event InnovationFeePaid(\n        uint128 indexed listingId, address indexed marketplaceOwner, address indexed currency, uint256 innovationFee\n    );\n\n    event RoyaltyPaid(\n        uint128 indexed listingId, address indexed royaltyReceiver, address indexed currency, uint256 royaltyAmount\n    );\n\n    event SellerProceedsPaid(\n        uint128 indexed listingId, address indexed seller, address indexed currency, uint256 sellerProceeds\n    );\n\n    event CollectionWhitelistRevokedCancelTriggered(uint128 indexed listingId, address indexed tokenAddress);\n\n    ///////////////\n    // Modifiers //\n    ///////////////\n\n    /// @notice Ensures the listing exists (seller \u2260 address(0)).\n    /// @dev Reverts with `IdeationMarket__NotListed` if the listing does not exist.\n    modifier listingExists(uint128 listingId) {\n        if (LibAppStorage.appStorage().listings[listingId].seller == address(0)) revert IdeationMarket__NotListed();\n        _;\n    }\n\n    /// @notice Prevents reentrancy attacks using a simple boolean lock.\n    /// @dev Uses AppStorage.reentrancyLock to work across all facets in the diamond.\n    modifier nonReentrant() {\n        AppStorage storage s = LibAppStorage.appStorage();\n        if (s.reentrancyLock) revert IdeationMarket__Reentrant();\n        s.reentrancyLock = true;\n        _;\n        s.reentrancyLock = false;\n    }\n\n    ////////////////////\n    // Main Functions //\n    ////////////////////\n\n    /// @notice Lists an NFT for sale (optional swap target, optional buyer whitelist, optional ERC-1155 partial buys).\n    /// @param tokenAddress NFT contract address (ERC-721 or ERC-1155).\n    /// @param tokenId Token id to list.\n    /// @param erc1155Holder Required if `erc1155Quantity > 0`: the address whose ERC-1155 balance is being listed (can be caller or an owner who authorized caller).\n    /// @param price Total listing price in wei. For ERC-1155 tokens with partial buys enabled, this price must be evenly divisible by `erc1155Quantity` to ensure consistent per-unit pricing.\n    /// @param desiredTokenId Token id of the desired NFT if `desiredTokenAddress != 0`.\n    /// @param desiredErc1155Quantity Desired quantity if the desired NFT is ERC-1155, else 0.\n    /// @param erc1155Quantity Quantity for ERC-1155 listing; must be 0 for ERC-721 listing.\n    /// @param buyerWhitelistEnabled If true, only pre-whitelisted buyers may purchase.\n    /// @param partialBuyEnabled If true and ERC-1155, buyers may purchase a subset of units; requires `price % erc1155Quantity == 0` and swap must be disabled.\n    /// @param allowedBuyers Optional initial whitelist addresses (only allowed if `buyerWhitelistEnabled == true`).\n    /// @dev Reverts if: collection not whitelisted; wrong token standard vs quantity; caller not owner/authorized; insufficient ERC-1155 balance;\n    /// partial-buy invalid (quantity \u2264 1 or price not divisible); ERC-721 already listed; invalid swap parameters; marketplace not approved.\n    /// Snapshots `s.innovationFee` into the listing\u2019s `feeRate`.\n    function createListing(\n        address tokenAddress,\n        uint256 tokenId,\n        address erc1155Holder,\n        uint256 price,\n        address currency,\n        address desiredTokenAddress,\n        uint256 desiredTokenId,\n        uint256 desiredErc1155Quantity, // >0 for swap ERC1155, 0 for only swap ERC721 or non swap\n        uint256 erc1155Quantity, // >0 for ERC1155, 0 for only ERC721\n        bool buyerWhitelistEnabled,\n        bool partialBuyEnabled,\n        address[] calldata allowedBuyers // whitelisted Buyers\n    ) external {\n        // Emergency pause check\n        if (LibDiamond.diamondStorage().paused) revert IdeationMarket__ContractPaused();\n\n        AppStorage storage s = LibAppStorage.appStorage();\n\n        // ============ Currency Validation ============\n        // Ensure the currency is allowed (prevents listing in scam/malicious tokens)\n        if (!s.allowedCurrencies[currency]) {\n            revert IdeationMarket__CurrencyNotAllowed();\n        }\n\n        // check if the Collection is Whitelisted\n        if (!s.whitelistedCollections[tokenAddress]) {\n            revert IdeationMarket__CollectionNotWhitelisted(tokenAddress);\n        }\n\n        // check if the user is an authorized Operator and set the seller Address to be the tokenHolders Address\n        address seller = address(0);\n        if (erc1155Quantity > 0) {\n            // check that the quantity matches the token Type\n            if (!IERC165(tokenAddress).supportsInterface(type(IERC1155).interfaceId)) {\n                if (!IERC165(tokenAddress).supportsInterface(type(IERC721).interfaceId)) {\n                    revert IdeationMarket__NotSupportedTokenStandard();\n                } else {\n                    revert IdeationMarket__WrongQuantityParameter();\n                }\n            }\n            IERC1155 token = IERC1155(tokenAddress);\n            // check if the user is authorized or the holder himself\n            if (msg.sender != erc1155Holder && !token.isApprovedForAll(erc1155Holder, msg.sender)) {\n                revert IdeationMarket__NotAuthorizedOperator();\n            }\n            // check that this 'erc1155Holder' is really the holder and that they hold enough token\n            uint256 balance = token.balanceOf(erc1155Holder, tokenId);\n            if (balance == 0) {\n                revert IdeationMarket__WrongErc1155HolderParameter();\n            }\n            if (balance < erc1155Quantity) {\n                revert IdeationMarket__SellerInsufficientTokenBalance(erc1155Quantity, balance);\n            }\n            seller = erc1155Holder;\n        } else {\n            // check that the quantity matches the token Type\n            if (!IERC165(tokenAddress).supportsInterface(type(IERC721).interfaceId)) {\n                if (!IERC165(tokenAddress).supportsInterface(type(IERC1155).interfaceId)) {\n                    revert IdeationMarket__NotSupportedTokenStandard();\n                } else {\n                    revert IdeationMarket__WrongQuantityParameter();\n                }\n            }\n            IERC721 token = IERC721(tokenAddress);\n            address tokenHolder = token.ownerOf(tokenId);\n            if (\n                msg.sender != tokenHolder && msg.sender != token.getApproved(tokenId)\n                    && !token.isApprovedForAll(tokenHolder, msg.sender)\n            ) {\n                revert IdeationMarket__NotAuthorizedOperator();\n            }\n            seller = tokenHolder;\n        }\n\n        // check validity of partialBuyEnabled Flag\n        if (erc1155Quantity <= 1 && partialBuyEnabled) {\n            revert IdeationMarket__PartialBuyNotPossible();\n        }\n\n        if (partialBuyEnabled) {\n            // price must be divisible by quantity\n            if (price % erc1155Quantity != 0) {\n                revert IdeationMarket__InvalidUnitPrice();\n            }\n            // forbid partialbuys if its a swap listing\n            if (desiredTokenAddress != address(0)) {\n                revert IdeationMarket__PartialBuyNotPossible();\n            }\n        }\n\n        // Prevent relisting an already-listed ERC721 NFT\n        if (erc1155Quantity == 0 && s.tokenToListingIds[tokenAddress][tokenId].length > 0) {\n            revert IdeationMarket__AlreadyListed();\n        }\n\n        // check Swap parameters\n        validateSwapParameters(\n            tokenAddress, tokenId, price, desiredTokenAddress, desiredTokenId, desiredErc1155Quantity\n        );\n\n        // ensure the MarketPlace has been Approved for transfer.\n        if (erc1155Quantity > 0) {\n            requireERC1155Approval(tokenAddress, seller);\n        } else {\n            requireERC721Approval(tokenAddress, tokenId);\n        }\n\n        s.listingIdCounter++;\n\n        uint128 newListingId = s.listingIdCounter;\n\n        s.listings[newListingId] = Listing({\n            listingId: newListingId,\n            tokenAddress: tokenAddress,\n            tokenId: tokenId,\n            erc1155Quantity: erc1155Quantity,\n            price: price,\n            feeRate: s.innovationFee,\n            seller: seller,\n            currency: currency,\n            buyerWhitelistEnabled: buyerWhitelistEnabled,\n            partialBuyEnabled: partialBuyEnabled,\n            desiredTokenAddress: desiredTokenAddress,\n            desiredTokenId: desiredTokenId,\n            desiredErc1155Quantity: desiredErc1155Quantity\n        });\n\n        s.tokenToListingIds[tokenAddress][tokenId].push(newListingId);\n\n        if (buyerWhitelistEnabled) {\n            if (allowedBuyers.length > 0) {\n                // delegate into BuyerWhitelistFacet on this Diamond\n                IBuyerWhitelistFacet(address(this)).addBuyerWhitelistAddresses(newListingId, allowedBuyers);\n            }\n        } else {\n            if (allowedBuyers.length > 0) revert IdeationMarket__WhitelistDisabled();\n        }\n\n        emit ListingCreated(\n            s.listingIdCounter,\n            tokenAddress,\n            tokenId,\n            erc1155Quantity,\n            price,\n            currency,\n            s.innovationFee,\n            seller,\n            buyerWhitelistEnabled,\n            partialBuyEnabled,\n            desiredTokenAddress,\n            desiredTokenId,\n            desiredErc1155Quantity\n        );\n    }\n\n    /// @notice Purchases a listing (optionally as a partial ERC-1155 buy and/or fulfilling a swap).\n    /// @param listingId The target listing id.\n    /// @param expectedPrice Caller's view of `listing.price` to guard against mid-tx updates.\n    /// @param expectedCurrency Caller's view of `listing.currency` to guard against mid-tx updates (front-run protection).\n    /// @param expectedErc1155Quantity Caller's view of `listing.erc1155Quantity` to guard against mid-tx updates.\n    /// @param expectedDesiredTokenAddress Caller's view of `listing.desiredTokenAddress` to guard against mid-tx updates.\n    /// @param expectedDesiredTokenId Caller's view of `listing.desiredTokenId` to guard against mid-tx updates.\n    /// @param expectedDesiredErc1155Quantity Caller's view of `listing.desiredErc1155Quantity` to guard against mid-tx updates.\n    /// @param erc1155PurchaseQuantity For ERC-1155: exact units to purchase (0 for ERC-721).\n    /// @param desiredErc1155Holder If fulfilling an ERC-1155 swap, the holder whose balance/approval is checked for the desired token.\n    /// @dev Reverts if: collection de-whitelisted; buyer not whitelisted (when enabled); terms mismatch (front-run protection);\n    /// invalid purchase quantity; partial buy disallowed; payment amount incorrect (must be exact for ETH); seller equals buyer; seller no longer owns/approved;\n    /// royalty exceeds proceeds; swap balance/approval insufficient.\n    /// Accounting: fee = `price * feeRate / 100_000`, royalty (ERC-2981) deducted from seller proceeds.\n    /// For ETH listings: requires exact msg.value (no overpayment allowed). For ERC-20 listings: uses buyer's approval to transfer directly to recipients.\n    /// Payments distributed atomically after NFT transfer: marketplace owner (innovation fee) \u2192 royalty receiver (if any, from curated collections) \u2192 seller (proceeds).\n    /// For swap listings, buyer's desired NFT is transferred to the seller before receiving the listed NFT.\n    /// Deprecated listings by the swap seller for that token are cleaned (swap-and-pop) if they can no longer be fulfilled.\n    /// If a whitelisted token is removed from the collection whitelist after being listed, the listing becomes unpurchasable and must be cleaned up using the cleanListing function. This cleanup process is handled by an offchain bot.\n    function purchaseListing(\n        uint128 listingId,\n        uint256 expectedPrice,\n        address expectedCurrency,\n        uint256 expectedErc1155Quantity,\n        address expectedDesiredTokenAddress,\n        uint256 expectedDesiredTokenId,\n        uint256 expectedDesiredErc1155Quantity,\n        uint256 erc1155PurchaseQuantity,\n        address desiredErc1155Holder\n    ) external payable nonReentrant listingExists(listingId) {\n        // Emergency pause check\n        if (LibDiamond.diamondStorage().paused) revert IdeationMarket__ContractPaused();\n\n        AppStorage storage s = LibAppStorage.appStorage();\n        Listing memory listedItem = s.listings[listingId];\n\n        // Block purchase if the collection was de-whitelisted after listing\n        if (!s.whitelistedCollections[listedItem.tokenAddress]) {\n            revert IdeationMarket__CollectionNotWhitelisted(listedItem.tokenAddress);\n        }\n\n        // BuyerWhitelist Check\n        if (listedItem.buyerWhitelistEnabled) {\n            if (!s.whitelistedBuyersByListingId[listingId][msg.sender]) {\n                revert IdeationMarket__BuyerNotWhitelisted(listingId, msg.sender);\n            }\n        }\n\n        // Check if Terms have changed in the meantime to guard against mid-tx updates (front-running protection)\n        if (\n            listedItem.price != expectedPrice || listedItem.currency != expectedCurrency\n                || listedItem.desiredTokenAddress != expectedDesiredTokenAddress\n                || listedItem.desiredTokenId != expectedDesiredTokenId\n                || listedItem.desiredErc1155Quantity != expectedDesiredErc1155Quantity\n                || listedItem.erc1155Quantity != expectedErc1155Quantity\n        ) {\n            revert IdeationMarket__ListingTermsChanged();\n        }\n\n        // Purchase\u2010quantity validations\n        if (\n            (listedItem.erc1155Quantity != 0 && erc1155PurchaseQuantity == 0)\n                || (listedItem.erc1155Quantity == 0 && erc1155PurchaseQuantity != 0)\n                || erc1155PurchaseQuantity > listedItem.erc1155Quantity\n        ) {\n            revert IdeationMarket__InvalidPurchaseQuantity();\n        }\n        if (!listedItem.partialBuyEnabled && erc1155PurchaseQuantity != listedItem.erc1155Quantity) {\n            revert IdeationMarket__PartialBuyNotPossible();\n        }\n\n        // setting the purchasePrice based on partialBuy quantity\n        uint256 purchasePrice = listedItem.price;\n\n        if (erc1155PurchaseQuantity > 0 && erc1155PurchaseQuantity != listedItem.erc1155Quantity) {\n            uint256 unitPrice = listedItem.price / listedItem.erc1155Quantity;\n            purchasePrice = unitPrice * erc1155PurchaseQuantity;\n        }\n\n        // Payment Validation\n        if (listedItem.currency == address(0)) {\n            // ETH listing: require EXACT msg.value (no overpayment)\n            if (msg.value != purchasePrice) {\n                revert IdeationMarket__PriceNotMet(listedItem.listingId, purchasePrice, msg.value);\n            }\n        } else {\n            // ERC-20 listing: msg.value must be 0\n            // Tokens will be transferred directly from buyer to recipients later using buyer's approval\n            if (msg.value > 0) {\n                revert IdeationMarket__WrongPaymentCurrency();\n            }\n        }\n\n        if (listedItem.desiredErc1155Quantity > 0 && desiredErc1155Holder == address(0)) {\n            revert IdeationMarket__WrongErc1155HolderParameter();\n        }\n\n        if (msg.sender == listedItem.seller) {\n            revert IdeationMarket__SameBuyerAsSeller();\n        }\n\n        // Check if the seller still owns the token and if the marketplace is still approved\n        if (listedItem.erc1155Quantity > 0) {\n            uint256 balance = IERC1155(listedItem.tokenAddress).balanceOf(listedItem.seller, listedItem.tokenId);\n            if (balance < erc1155PurchaseQuantity) {\n                revert IdeationMarket__SellerInsufficientTokenBalance(erc1155PurchaseQuantity, balance);\n            }\n            requireERC1155Approval(listedItem.tokenAddress, listedItem.seller);\n        } else {\n            address ownerToken = IERC721(listedItem.tokenAddress).ownerOf(listedItem.tokenId);\n            if (ownerToken != listedItem.seller) {\n                revert IdeationMarket__SellerNotTokenOwner(listingId);\n            }\n            requireERC721Approval(listedItem.tokenAddress, listedItem.tokenId);\n        }\n\n        // Calculate payment splits (will be distributed after NFT transfer)\n        uint256 innovationFee = ((purchasePrice * listedItem.feeRate) / 100000);\n        uint256 remainingProceeds = purchasePrice - innovationFee;\n\n        address royaltyReceiver = address(0);\n        uint256 royaltyAmount = 0;\n\n        // Check for ERC2981 royalties\n        if (IERC165(listedItem.tokenAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            (royaltyReceiver, royaltyAmount) =\n                IERC2981(listedItem.tokenAddress).royaltyInfo(listedItem.tokenId, purchasePrice);\n            if (royaltyAmount > 0) {\n                if (remainingProceeds < royaltyAmount) revert IdeationMarket__RoyaltyFeeExceedsProceeds();\n                remainingProceeds -= royaltyAmount;\n            }\n        }\n\n        uint256 sellerProceeds = remainingProceeds;\n\n        // in case it's a swap listing, send that desired token (the frontend approves the marketplace for that action beforehand)\n        if (listedItem.desiredTokenAddress != address(0)) {\n            address desiredOwner = address(0); // initializing this for cleanup\n            address obsoleteSeller = address(0); // initializing this for cleanup\n            uint256 remainingERC1155Balance = 0; // initializing this for cleanup\n            if (listedItem.desiredErc1155Quantity > 0) {\n                // For ERC1155: Check that buyer holds enough token.\n                IERC1155 desiredToken = IERC1155(listedItem.desiredTokenAddress);\n                uint256 swapBalance = desiredToken.balanceOf(desiredErc1155Holder, listedItem.desiredTokenId);\n                if (swapBalance == 0) revert IdeationMarket__WrongErc1155HolderParameter();\n                if (\n                    msg.sender != desiredErc1155Holder\n                        && !desiredToken.isApprovedForAll(desiredErc1155Holder, msg.sender)\n                ) {\n                    revert IdeationMarket__NotAuthorizedOperator();\n                }\n                if (swapBalance < listedItem.desiredErc1155Quantity) {\n                    revert IdeationMarket__InsufficientSwapTokenBalance(listedItem.desiredErc1155Quantity, swapBalance);\n                }\n\n                // Check approval\n                requireERC1155Approval(listedItem.desiredTokenAddress, desiredErc1155Holder);\n\n                // Perform the safe swap transfer buyer to seller.\n                IERC1155(listedItem.desiredTokenAddress).safeTransferFrom(\n                    desiredErc1155Holder,\n                    listedItem.seller,\n                    listedItem.desiredTokenId,\n                    listedItem.desiredErc1155Quantity,\n                    \"\"\n                );\n\n                obsoleteSeller = desiredErc1155Holder; // for cleanup\n                remainingERC1155Balance = desiredToken.balanceOf(obsoleteSeller, listedItem.desiredTokenId); // for cleanup\n            } else {\n                IERC721 desiredToken = IERC721(listedItem.desiredTokenAddress);\n                desiredOwner = desiredToken.ownerOf(listedItem.desiredTokenId);\n                // For ERC721: Check ownership.\n                if (\n                    msg.sender != desiredOwner && msg.sender != desiredToken.getApproved(listedItem.desiredTokenId)\n                        && !desiredToken.isApprovedForAll(desiredOwner, msg.sender)\n                ) {\n                    revert IdeationMarket__NotAuthorizedOperator();\n                }\n\n                // Check approval\n                requireERC721Approval(listedItem.desiredTokenAddress, listedItem.desiredTokenId);\n\n                // Perform the safe swap transfer buyer to seller.\n                desiredToken.safeTransferFrom(desiredOwner, listedItem.seller, listedItem.desiredTokenId);\n\n                obsoleteSeller = desiredOwner; // for cleanup\n            }\n\n            // in case the desiredToken is listed already, delete that now deprecated listing to cleanup\n            uint128[] storage deprecatedListingArray =\n                s.tokenToListingIds[listedItem.desiredTokenAddress][listedItem.desiredTokenId];\n\n            for (uint256 i = deprecatedListingArray.length; i != 0;) {\n                unchecked {\n                    i--;\n                }\n                uint128 depId = deprecatedListingArray[i];\n                Listing storage dep = s.listings[depId];\n                // If the seller of that listing is the same as the obsoleteSeller (the one who just sold his token to the current buyer)\n                // and in case of an ERC1155 listing, if the obsoleteSeller does not hold enough token anymore to cover the\n                // desiredErc1155Quantity of that listing, that listing needs to get removed. If it is an erc721 listing,\n                // it's enough that the obsoleteSeller is the seller of that listing, to remove that listing.\n                if (\n                    dep.seller == obsoleteSeller\n                        && (listedItem.desiredErc1155Quantity == 0 || dep.erc1155Quantity > remainingERC1155Balance)\n                ) {\n                    // remove the obsolete listing\n                    delete s.listings[depId];\n                    emit ListingCanceled(\n                        depId, listedItem.desiredTokenAddress, listedItem.desiredTokenId, obsoleteSeller, address(this)\n                    );\n                    deprecatedListingArray[i] = deprecatedListingArray[deprecatedListingArray.length - 1];\n                    deprecatedListingArray.pop();\n                }\n            }\n        }\n\n        // Update or delete the listing\n        bool partialBuy = false;\n        if (erc1155PurchaseQuantity == listedItem.erc1155Quantity) {\n            // fully bought \u2192 remove\n            deleteListingAndCleanup(s, listingId, listedItem.tokenAddress, listedItem.tokenId);\n        } else {\n            // partially bought \u2192 reduce remaining\n            s.listings[listingId].erc1155Quantity -= erc1155PurchaseQuantity;\n            s.listings[listingId].price -= purchasePrice;\n            partialBuy = true;\n        }\n\n        // Transfer tokens based on the token standard.\n        if (erc1155PurchaseQuantity > 0) {\n            IERC1155(listedItem.tokenAddress).safeTransferFrom(\n                listedItem.seller, msg.sender, listedItem.tokenId, erc1155PurchaseQuantity, \"\"\n            );\n        } else {\n            IERC721(listedItem.tokenAddress).safeTransferFrom(listedItem.seller, msg.sender, listedItem.tokenId);\n        }\n\n        // Distribute payments atomically after NFT transfer (security: CEI pattern)\n        _distributePayments(\n            listedItem.currency,\n            msg.sender,\n            sellerProceeds,\n            listedItem.seller,\n            innovationFee,\n            LibDiamond.contractOwner(),\n            royaltyReceiver,\n            royaltyAmount,\n            listingId\n        );\n\n        emit ListingPurchased(\n            listedItem.listingId,\n            listedItem.tokenAddress,\n            listedItem.tokenId,\n            erc1155PurchaseQuantity,\n            partialBuy,\n            purchasePrice,\n            listedItem.currency,\n            listedItem.feeRate,\n            listedItem.seller,\n            msg.sender,\n            listedItem.desiredTokenAddress,\n            listedItem.desiredTokenId,\n            listedItem.desiredErc1155Quantity\n        );\n    }\n\n    /// @notice Cancels an existing listing.\n    /// @dev Diamond owner may cancel any listing. Otherwise, only the seller or an authorized operator\n    /// (ERC-721: token approval or approvalForAll; ERC-1155: approvalForAll) may cancel.\n    /// Uses `try/catch` on external token calls to avoid bubbling token contract reverts.\n    function cancelListing(uint128 listingId) public listingExists(listingId) {\n        AppStorage storage s = LibAppStorage.appStorage();\n        Listing memory listedItem = s.listings[listingId];\n\n        // allow the diamondOwner to force cancel any listing\n        address diamondOwner = LibDiamond.contractOwner();\n        if (msg.sender == diamondOwner) {\n            // delete Listing\n            deleteListingAndCleanup(s, listingId, listedItem.tokenAddress, listedItem.tokenId);\n            emit ListingCanceled(listingId, listedItem.tokenAddress, listedItem.tokenId, listedItem.seller, msg.sender);\n            return;\n        }\n\n        bool isAuthorized = false;\n        // check if its an ERC721 or ERC1155 token contract\n        if (listedItem.erc1155Quantity == 0) {\n            IERC721 token = IERC721(listedItem.tokenAddress);\n\n            // check if the caller is the item seller\n            isAuthorized = (msg.sender == listedItem.seller);\n\n            if (!isAuthorized) {\n                // try check if the caller is approved for the sellers token by the token contract\n                try token.getApproved(listedItem.tokenId) returns (address approvedAddress) {\n                    if (approvedAddress == msg.sender) {\n                        isAuthorized = true;\n                    }\n                } catch { /* ignore */ }\n            }\n\n            if (!isAuthorized) {\n                // try check if the caller is approvedForAll the sellers tokens by the token contract\n                try token.isApprovedForAll(listedItem.seller, msg.sender) returns (bool approved) {\n                    if (approved) {\n                        isAuthorized = true;\n                    }\n                } catch { /* ignore */ }\n            }\n        } else {\n            // check if the caller is the item seller\n            isAuthorized = (msg.sender == listedItem.seller);\n\n            if (!isAuthorized) {\n                try IERC1155(listedItem.tokenAddress).isApprovedForAll(listedItem.seller, msg.sender) returns (\n                    bool approved\n                ) {\n                    if (approved) {\n                        isAuthorized = true;\n                    }\n                } catch { /* ignore */ }\n            }\n        }\n\n        if (isAuthorized) {\n            // delete Listing\n            deleteListingAndCleanup(s, listingId, listedItem.tokenAddress, listedItem.tokenId);\n            emit ListingCanceled(listingId, listedItem.tokenAddress, listedItem.tokenId, listedItem.seller, msg.sender);\n            return;\n        }\n        revert IdeationMarket__NotAuthorizedToCancel();\n    }\n\n    /// @notice Updates listing terms (price, desired swap target, quantities, flags).\n    /// @param listingId The listing id to update.\n    /// @param newPrice New total price (for ERC-1155: total for `newErc1155Quantity`).\n    /// @param newDesiredTokenAddress New desired NFT address for swap (0 for non-swap).\n    /// @param newDesiredTokenId New desired token id for swap.\n    /// @param newDesiredErc1155Quantity New desired ERC-1155 quantity for swap (0 for ERC-721 swap or non-swap).\n    /// @param newErc1155Quantity New ERC-1155 quantity; must be 0 for ERC-721 listings.\n    /// @param newBuyerWhitelistEnabled Whether whitelist gating is enabled.\n    /// @param newPartialBuyEnabled Whether partial buys (ERC-1155 only) are enabled.\n    /// @param newAllowedBuyers Optional addresses to add when enabling whitelist.\n    /// @dev Reverts if token standard/quantity mismatch; caller not owner/authorized; insufficient ERC-1155 balance;\n    /// marketplace not approved; collection de-whitelisted (auto-cancels and emits); invalid partial-buy setup\n    /// (quantity \u2264 1 or price not divisible or swap enabled); invalid swap parameters.\n    /// Updates `feeRate` to the current `innovationFee` snapshot.\n    /// Auto-cancels the listing if the collection whitelist status has been revoked since the original listing was created.\n    /// Emits `CollectionWhitelistRevokedCancelTriggered` when this occurs and exits early.\n    function updateListing(\n        uint128 listingId,\n        uint256 newPrice,\n        address newCurrency,\n        address newDesiredTokenAddress,\n        uint256 newDesiredTokenId,\n        uint256 newDesiredErc1155Quantity,\n        uint256 newErc1155Quantity,\n        bool newBuyerWhitelistEnabled,\n        bool newPartialBuyEnabled,\n        address[] calldata newAllowedBuyers\n    ) external listingExists(listingId) {\n        // Emergency pause check\n        if (LibDiamond.diamondStorage().paused) revert IdeationMarket__ContractPaused();\n\n        AppStorage storage s = LibAppStorage.appStorage();\n        Listing storage listedItem = s.listings[listingId];\n\n        // cache variables for gas efficiency\n        address tokenAddress = listedItem.tokenAddress;\n        address seller = listedItem.seller;\n        uint256 tokenId = listedItem.tokenId;\n        uint256 erc1155Quantity = listedItem.erc1155Quantity;\n\n        // ensure the newQuantity is still valid according to the token Standard ( 0 for ERC721, >0 for ERC1155)\n        if (newErc1155Quantity > 0) {\n            if (erc1155Quantity == 0) {\n                revert IdeationMarket__WrongQuantityParameter();\n            }\n        } else {\n            if (erc1155Quantity > 0) {\n                revert IdeationMarket__WrongQuantityParameter();\n            }\n        }\n\n        // check if the user is an authorized operator and use interface check to ensure the MarketPlace is still Approved for transfer and seller holds enough token\n        if (newErc1155Quantity > 0) {\n            IERC1155 token = IERC1155(tokenAddress);\n            // check if the user is authorized\n            if (msg.sender != seller && !token.isApprovedForAll(seller, msg.sender)) {\n                revert IdeationMarket__NotAuthorizedOperator();\n            }\n            uint256 balance = token.balanceOf(seller, tokenId);\n            if (balance < newErc1155Quantity) {\n                revert IdeationMarket__SellerInsufficientTokenBalance(newErc1155Quantity, balance);\n            }\n            requireERC1155Approval(tokenAddress, seller);\n        } else {\n            IERC721 token = IERC721(tokenAddress);\n            address tokenHolder = token.ownerOf(tokenId);\n            if (\n                msg.sender != tokenHolder && msg.sender != token.getApproved(tokenId)\n                    && !token.isApprovedForAll(tokenHolder, msg.sender)\n            ) {\n                revert IdeationMarket__NotAuthorizedOperator();\n            }\n            requireERC721Approval(tokenAddress, tokenId);\n        }\n\n        //Validates collection whitelist status. If the collection was de-whitelisted after the original listing,\n        // the listing is automatically canceled and `CollectionWhitelistRevokedCancelTriggered` is emitted.\n        if (!s.whitelistedCollections[tokenAddress]) {\n            cancelListing(listingId);\n            emit CollectionWhitelistRevokedCancelTriggered(listingId, tokenAddress);\n            return;\n        }\n\n        // Ensure the new currency is allowed\n        if (!s.allowedCurrencies[newCurrency]) {\n            revert IdeationMarket__CurrencyNotAllowed();\n        }\n\n        // check validity of newPartialBuyEnabled Flag\n        if (newErc1155Quantity <= 1 && newPartialBuyEnabled) {\n            revert IdeationMarket__PartialBuyNotPossible();\n        }\n\n        // if partial buys allowed, require even per-unit price\n        if (newPartialBuyEnabled) {\n            // price must be divisible by quantity\n            if (newPrice % newErc1155Quantity != 0) {\n                revert IdeationMarket__InvalidUnitPrice();\n            }\n            // forbid partialbuys if its a swap listing\n            if (newDesiredTokenAddress != address(0)) {\n                revert IdeationMarket__PartialBuyNotPossible();\n            }\n        }\n\n        // check Swap parameters\n        validateSwapParameters(\n            tokenAddress, tokenId, newPrice, newDesiredTokenAddress, newDesiredTokenId, newDesiredErc1155Quantity\n        );\n\n        listedItem.price = newPrice;\n        listedItem.currency = newCurrency;\n        listedItem.desiredTokenAddress = newDesiredTokenAddress;\n        listedItem.desiredTokenId = newDesiredTokenId;\n        listedItem.desiredErc1155Quantity = newDesiredErc1155Quantity;\n        listedItem.erc1155Quantity = newErc1155Quantity;\n        listedItem.feeRate = s.innovationFee;\n        listedItem.buyerWhitelistEnabled = newBuyerWhitelistEnabled;\n        listedItem.partialBuyEnabled = newPartialBuyEnabled;\n\n        if (newBuyerWhitelistEnabled) {\n            if (newAllowedBuyers.length > 0) {\n                // delegate into BuyerWhitelistFacet on this Diamond\n                IBuyerWhitelistFacet(address(this)).addBuyerWhitelistAddresses(listingId, newAllowedBuyers);\n            }\n        } else {\n            if (newAllowedBuyers.length > 0) revert IdeationMarket__WhitelistDisabled();\n        }\n\n        emit ListingUpdated(\n            listedItem.listingId,\n            tokenAddress,\n            tokenId,\n            newErc1155Quantity,\n            newPrice,\n            newCurrency,\n            listedItem.feeRate,\n            seller,\n            newBuyerWhitelistEnabled,\n            newPartialBuyEnabled,\n            newDesiredTokenAddress,\n            newDesiredTokenId,\n            newDesiredErc1155Quantity\n        );\n    }\n\n    /// @notice Updates the marketplace fee rate  (e.g., 1_000 for 1% with a denominator of 100_000).\n    /// @dev Owner-only. Existing listings are unaffected (they keep their stored `feeRate`).\n    /// Emits `InnovationFeeUpdated`.\n    function setInnovationFee(uint32 newFee) external {\n        LibDiamond.enforceIsContractOwner();\n        AppStorage storage s = LibAppStorage.appStorage();\n        uint32 previousFee = s.innovationFee;\n        s.innovationFee = newFee;\n        emit InnovationFeeUpdated(previousFee, newFee);\n    }\n\n    /// @notice Validates and removes an invalid listing (ownership/approval/whitelist checks).\n    /// @dev Intended for off-chain maintenance bots but callable by anyone. For ERC-721/1155:\n    /// verifies owner/balance and marketplace approval (using `try/catch` to handle token contract reverts).\n    /// Uses `do-while(false)` pattern as a structured alternative to goto - allows early exit via `break`\n    /// statements without nested if-else blocks when any validation fails.\n    /// If invalid, deletes the listing and emits `ListingCanceledDueToInvalidListing`; otherwise reverts `IdeationMarket__StillApproved`.\n    function cleanListing(uint128 listingId) external listingExists(listingId) {\n        AppStorage storage s = LibAppStorage.appStorage();\n        Listing memory listedItem = s.listings[listingId];\n\n        bool invalid = false;\n\n        // Using do-while(false) loop as a control flow structure - allows clean early exit via 'break'\n        // instead of deeply nested if-else conditions when validation checks fail\n        do {\n            // check if the Collection is still Whitelisted\n            if (s.whitelistedCollections[listedItem.tokenAddress]) {\n                // check ownership and approval depending on token type\n                if (listedItem.erc1155Quantity > 0) {\n                    IERC1155 token = IERC1155(listedItem.tokenAddress);\n\n                    // balanceOf may revert on invalid tokens \u2192 delete\n                    try token.balanceOf(listedItem.seller, listedItem.tokenId) returns (uint256 balance) {\n                        if (balance < listedItem.erc1155Quantity) {\n                            invalid = true;\n                            break;\n                        }\n                    } catch {\n                        invalid = true;\n                        break;\n                    }\n\n                    // isApprovedForAll may revert \u2192 delete\n                    try token.isApprovedForAll(listedItem.seller, address(this)) returns (bool approved) {\n                        if (!approved) {\n                            invalid = true;\n                            break;\n                        }\n                    } catch {\n                        invalid = true;\n                        break;\n                    }\n                } else {\n                    IERC721 token = IERC721(listedItem.tokenAddress);\n\n                    // ownerOf may revert for burned/nonexistent \u2192 delete\n                    try token.ownerOf(listedItem.tokenId) returns (address currOwner) {\n                        if (currOwner != listedItem.seller) {\n                            invalid = true;\n                            break;\n                        }\n                    } catch {\n                        invalid = true;\n                        break;\n                    }\n\n                    // getApproved may revert \u2192 delete\n                    try token.getApproved(listedItem.tokenId) returns (address approved) {\n                        if (approved != address(this)) {\n                            // isApprovedForAll may also revert \u2192 delete\n                            try token.isApprovedForAll(listedItem.seller, address(this)) returns (bool approvedForAll) {\n                                if (!approvedForAll) {\n                                    invalid = true;\n                                    break;\n                                }\n                            } catch {\n                                invalid = true;\n                                break;\n                            }\n                        }\n                    } catch {\n                        invalid = true;\n                        break;\n                    }\n                }\n            } else {\n                invalid = true;\n                break;\n            }\n        } while (false);\n\n        if (invalid) {\n            deleteListingAndCleanup(s, listingId, listedItem.tokenAddress, listedItem.tokenId);\n            emit ListingCanceledDueToInvalidListing(\n                listingId, listedItem.tokenAddress, listedItem.tokenId, listedItem.seller, msg.sender\n            );\n            return;\n        }\n\n        revert IdeationMarket__StillApproved();\n    }\n\n    //////////////////////\n    // Helper Functions //\n    //////////////////////\n\n    /// @notice Requires this diamond to be approved to transfer the ERC-721 token.\n    /// @dev Accepts either token-level approval (`getApproved`) or operator approval (`isApprovedForAll`).\n    /// Reverts `IdeationMarket__NotApprovedForMarketplace` if neither is set.\n    function requireERC721Approval(address tokenAddress, uint256 tokenId) internal view {\n        IERC721 token = IERC721(tokenAddress);\n        if (\n            !(\n                token.getApproved(tokenId) == address(this)\n                    || token.isApprovedForAll(token.ownerOf(tokenId), address(this))\n            )\n        ) {\n            revert IdeationMarket__NotApprovedForMarketplace();\n        }\n    }\n\n    /// @notice Requires this diamond to be approved as operator for an ERC-1155 holder.\n    /// @dev Checks `isApprovedForAll(tokenOwner, address(this))`\n    /// Reverts on failure.\n    function requireERC1155Approval(address tokenAddress, address tokenOwner) internal view {\n        if (!IERC1155(tokenAddress).isApprovedForAll(tokenOwner, address(this))) {\n            revert IdeationMarket__NotApprovedForMarketplace();\n        }\n    }\n\n    /// @notice Validates swap configuration for a listing.\n    /// @dev Disallows swapping for the same token (same contract + id).\n    /// Non-swap: `desiredTokenAddress == 0`, `desiredTokenId == 0`, `desiredErc1155Quantity == 0`, and `price > 0`.\n    /// Swap ERC-1155: `desiredErc1155Quantity > 0` and desired contract must support ERC-1155.\n    /// Swap ERC-721: `desiredErc1155Quantity == 0` and desired contract must support ERC-721.\n    function validateSwapParameters(\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 price,\n        address desiredTokenAddress,\n        uint256 desiredTokenId,\n        uint256 desiredErc1155Quantity\n    ) private view {\n        if (desiredTokenAddress == address(0)) {\n            if (desiredTokenId != 0) revert IdeationMarket__InvalidNoSwapParameters();\n            if (desiredErc1155Quantity != 0) revert IdeationMarket__InvalidNoSwapParameters();\n            if (price == 0) revert IdeationMarket__FreeListingsNotSupported();\n        } else {\n            if (desiredErc1155Quantity > 0) {\n                if (!IERC165(desiredTokenAddress).supportsInterface(type(IERC1155).interfaceId)) {\n                    revert IdeationMarket__NotSupportedTokenStandard();\n                }\n            }\n            if (desiredErc1155Quantity == 0) {\n                if (!IERC165(desiredTokenAddress).supportsInterface(type(IERC721).interfaceId)) {\n                    revert IdeationMarket__NotSupportedTokenStandard();\n                }\n            }\n            if (tokenAddress == desiredTokenAddress && tokenId == desiredTokenId) {\n                revert IdeationMarket__NoSwapForSameToken();\n            }\n        }\n    }\n\n    /// @notice Deletes a listing and removes its id from the reverse index for (tokenAddress, tokenId).\n    /// @dev Uses swap-and-pop on `tokenToListingIds[tokenAddress][tokenId]` to keep the array compact.\n    function deleteListingAndCleanup(AppStorage storage s, uint128 listingId, address tokenAddress, uint256 tokenId)\n        internal\n    {\n        delete s.listings[listingId];\n\n        uint128[] storage listingArray = s.tokenToListingIds[tokenAddress][tokenId];\n        for (uint256 i = listingArray.length; i != 0;) {\n            unchecked {\n                i--;\n            }\n            if (listingArray[i] == listingId) {\n                listingArray[i] = listingArray[listingArray.length - 1];\n                listingArray.pop();\n            }\n        }\n    }\n\n    /// @notice Distributes payment directly from buyer to all recipients atomically.\n    /// @dev Called AFTER NFT transfer to prevent reentrancy. For ETH: forwards from contract balance.\n    /// For ERC-20: uses buyer's approval to transfer directly (contract never holds tokens).\n    /// Payment order: marketplace owner (most trusted) \u2192 royalty receiver \u2192 seller (least trusted).\n    /// @param currency Payment currency (address(0) = ETH, otherwise ERC-20).\n    /// @param buyer Address of the buyer (for ERC-20 transferFrom source).\n    /// @param sellerProceeds Amount to send to seller.\n    /// @param seller Seller address.\n    /// @param innovationFee Marketplace fee amount.\n    /// @param marketplaceOwner Marketplace owner address.\n    /// @param royaltyReceiver Royalty recipient (address(0) if no royalty).\n    /// @param royaltyAmount Royalty amount (0 if no royalty).\n    /// @param listingId For RoyaltyPaid event emission.\n\n    function _distributePayments(\n        address currency,\n        address buyer,\n        uint256 sellerProceeds,\n        address seller,\n        uint256 innovationFee,\n        address marketplaceOwner,\n        address royaltyReceiver,\n        uint256 royaltyAmount,\n        uint128 listingId\n    ) private {\n        if (currency == address(0)) {\n            // ===== NATIVE ETH DISTRIBUTION =====\n            // Diamond received ETH via msg.value, now forward it\n\n            // 1. Pay marketplace owner FIRST (most trusted)\n            (bool successFee,) = payable(marketplaceOwner).call{value: innovationFee}(\"\");\n            if (!successFee) revert IdeationMarket__EthTransferFailed(marketplaceOwner);\n            emit InnovationFeePaid(listingId, marketplaceOwner, currency, innovationFee);\n\n            // 2. Pay royalty receiver SECOND\n            if (royaltyAmount > 0 && royaltyReceiver != address(0)) {\n                (bool successRoyalty,) = payable(royaltyReceiver).call{value: royaltyAmount}(\"\");\n                if (!successRoyalty) revert IdeationMarket__EthTransferFailed(royaltyReceiver);\n                emit RoyaltyPaid(listingId, royaltyReceiver, currency, royaltyAmount);\n            }\n\n            // 3. Pay seller LAST (least trusted)\n            (bool successSeller,) = payable(seller).call{value: sellerProceeds}(\"\");\n            if (!successSeller) revert IdeationMarket__EthTransferFailed(seller);\n            emit SellerProceedsPaid(listingId, seller, currency, sellerProceeds);\n        } else {\n            // ===== ERC-20 DISTRIBUTION =====\n            // Use buyer's approval to transfer directly: buyer \u2192 recipients\n            // Diamond NEVER holds the tokens\n\n            // 1. Pay marketplace owner FIRST (most trusted)\n            _safeTransferFrom(currency, buyer, marketplaceOwner, innovationFee);\n            emit InnovationFeePaid(listingId, marketplaceOwner, currency, innovationFee);\n\n            // 2. Pay royalty receiver SECOND\n            if (royaltyAmount > 0 && royaltyReceiver != address(0)) {\n                _safeTransferFrom(currency, buyer, royaltyReceiver, royaltyAmount);\n                emit RoyaltyPaid(listingId, royaltyReceiver, currency, royaltyAmount);\n            }\n\n            // 3. Pay seller LAST (least trusted)\n            _safeTransferFrom(currency, buyer, seller, sellerProceeds);\n            emit SellerProceedsPaid(listingId, seller, currency, sellerProceeds);\n        }\n    }\n\n    /// @notice SafeERC20-style transferFrom that handles non-standard tokens.\n    /// @dev Handles tokens like USDT that don't return bool, and tokens that return false on failure.\n    /// Uses low-level call to avoid ABI decoding issues with non-compliant ERC-20 tokens.\n    /// @param token ERC-20 token address.\n    /// @param from Address to transfer from.\n    /// @param to Address to transfer to.\n    /// @param amount Amount to transfer.\n    function _safeTransferFrom(address token, address from, address to, uint256 amount) private {\n        // Build the calldata for ERC20.transferFrom(address,address,uint256)\n        // Function selector: bytes4(keccak256(\"transferFrom(address,address,uint256)\")) = 0x23b872dd\n        bytes memory data = abi.encodeWithSelector(0x23b872dd, from, to, amount);\n\n        // Call the token contract\n        (bool success, bytes memory returndata) = token.call(data);\n\n        // Check for success:\n        // 1. Call must not revert\n        // 2. If returndata exists, it must decode to true (handles tokens that return bool)\n        // 3. If no returndata, assume success (handles USDT, XAUt that don't return anything)\n        if (!success || (returndata.length > 0 && !abi.decode(returndata, (bool)))) {\n            revert IdeationMarket__ERC20TransferFailed(token, to);\n        }\n    }\n\n    // View / Getter functions are implemented in GetterFacet.sol to maintain separation of concerns in the diamond pattern.\n}\n"
    },
    "src/interfaces/IBuyerWhitelistFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @title IBuyerWhitelistFacet\n/// @notice Allows listing facets to add/remove whitelisted buyers by listingId\ninterface IBuyerWhitelistFacet {\n    /// @notice Batch adds buyer addresses to a listing\u2019s whitelist.\n    /// @param listingId The ID of the listing (as assigned in IdeationMarketFacet).\n    /// @param allowedBuyers The array of buyer addresses to whitelist.\n    function addBuyerWhitelistAddresses(uint128 listingId, address[] calldata allowedBuyers) external;\n\n    /// @notice Batch removes buyer addresses from a listing\u2019s whitelist.\n    /// @param listingId The ID of the listing.\n    /// @param disallowedBuyers The array of buyer addresses to remove.\n    function removeBuyerWhitelistAddresses(uint128 listingId, address[] calldata disallowedBuyers) external;\n}\n"
    },
    "src/interfaces/IDiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * \\\n * Author: Nick Mudge <nickATperfectabstractions.com> (https://twitter.com/mudgen)\n * EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n * /*****************************************************************************\n */\ninterface IDiamondCutFacet {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "src/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.28;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.28;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     *\n     * NOTE: ERC-2981 allows setting the royalty to 100% of the price. In that case all the price would be sent to the\n     * royalty receiver and 0 tokens to the seller. Contracts dealing with royalty should consider empty transfers.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.28;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "src/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/// @notice Listing snapshot stored under a unique `listingId`.\n/// @dev `feeRate` is captured at listing time (denominator = 100_000). `erc1155Quantity`\n/// uses the convention: `0` for ERC-721 listings, `>0` for ERC-1155 (must be \u22651).\nstruct Listing {\n    /// @notice Unique listing identifier.\n    uint128 listingId;\n    /// @notice Marketplace fee rate at the time of listing.\n    /// @dev Denominator is 100_000 (e.g., 1_000 = 1%). Stored to make fees stable across updates.\n    uint32 feeRate;\n    /// @notice If true, only whitelisted buyers may purchase this listing.\n    bool buyerWhitelistEnabled;\n    /// @notice If true and ERC-1155, allows partial purchases (per-unit price must divide evenly).\n    bool partialBuyEnabled;\n    // 38 bytes padding for future tiny vars\n    /// @notice NFT contract being sold (ERC-721 or ERC-1155).\n    address tokenAddress;\n    /// @notice Token id within `tokenAddress`.\n    uint256 tokenId;\n    /// @notice Quantity listed when selling ERC-1155; must be 0 for ERC-721.\n    uint256 erc1155Quantity;\n    /// @notice Total listing price in wei (for ERC-1155: total for all `erc1155Quantity` units).\n    uint256 price;\n    /// @notice Holder address captured at listing time.\n    address seller;\n    /// @notice Currency for this listing. address(0) = ETH, otherwise ERC-20 token address.\n    /// @dev Must be in the allowedCurrencies mapping at listing creation time.\n    address currency;\n    /// @notice Optional desired NFT contract for swap listings (address(0) means no swap).\n    address desiredTokenAddress;\n    /// @notice Desired token id (swap only).\n    uint256 desiredTokenId;\n    /// @notice Desired ERC-1155 quantity for swap (0 for ERC-721 swap or non-swap).\n    uint256 desiredErc1155Quantity;\n}\n\n/// @notice Application-level storage shared by all facets.\n/// @dev Lives at `APP_STORAGE_POSITION` and is accessed via `LibAppStorage.appStorage()`.\nstruct AppStorage {\n    /// @notice Monotonic counter for new listing ids.\n    uint128 listingIdCounter;\n    /// @notice Marketplace fee rate (denominator 100_000; e.g., 1_000 = 1%).\n    /// @dev Used as the default/current fee; listings snapshot this into `Listing.feeRate`.\n    uint32 innovationFee;\n    /// @notice Max number of addresses accepted per buyer whitelist batch (Verified stability at 300).\n    uint16 buyerWhitelistMaxBatchSize;\n    /// @notice Simple boolean reentrancy lock.\n    bool reentrancyLock;\n    // 9\u00a0bytes padding for future tiny vars\n    /// @notice Primary listing registry by id.\n    mapping(uint128 listingId => Listing listing) listings;\n    /// @notice Reverse index: NFT (contract,id) \u2192 active listing ids.\n    mapping(address tokenContract => mapping(uint256 tokenId => uint128[] listingIds)) tokenToListingIds;\n    /// @notice Allowed currencies for listings (curated list to prevent scam tokens).\n    /// @dev address(0) = ETH is always allowed.\n    mapping(address currency => bool allowed) allowedCurrencies;\n    /// @notice Iterable list of allowed currencies.\n    address[] allowedCurrenciesArray;\n    /// @notice Index helper for `allowedCurrenciesArray`.\n    /// @dev Maps currency address => index in array. Check allowedCurrencies[addr] first to distinguish from index 0.\n    mapping(address currency => uint256 index) allowedCurrenciesIndex;\n    /// @notice Collection whitelist flags set by the Diamond Owner to curate Utility Token Contracts.\n    mapping(address collection => bool isWhitelisted) whitelistedCollections;\n    /// @notice Iterable list of whitelisted collections.\n    address[] whitelistedCollectionsArray;\n    /// @notice Index helper for `whitelistedCollectionsArray`.\n    mapping(address collection => uint256 index) whitelistedCollectionsIndex;\n    /// @notice Per-listing buyer whitelist set by the listing seller.\n    mapping(uint128 listingId => mapping(address buyer => bool isWhitelisted)) whitelistedBuyersByListingId;\n}\n\n/// @title LibAppStorage\n/// @notice Canonical application storage for the IdeationMarket diamond (separate from LibDiamond storage).\n/// @dev All marketplace facets `delegatecall` into the diamond and must read/write this struct via `appStorage()`.\n/// Upgrade rule: append new fields only; never reorder/remove existing fields to avoid storage collisions.\nlibrary LibAppStorage {\n    /// @notice Canonical storage slot for `AppStorage`.\n    /// @dev keccak256(\"diamond.standard.app.storage\").\n    bytes32 constant APP_STORAGE_POSITION = keccak256(\"diamond.standard.app.storage\");\n\n    /// @notice Returns a pointer to `AppStorage` at the canonical slot.\n    /// @dev Inline assembly assigns the slot to the returned storage reference.\n    function appStorage() internal pure returns (AppStorage storage s) {\n        bytes32 appStoragePosition = APP_STORAGE_POSITION;\n        assembly {\n            s.slot := appStoragePosition\n        }\n    }\n}\n"
    },
    "src/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * \\\n * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n * EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n * --- optimized by wolf3i\n * /*****************************************************************************\n */\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\n/// @title LibDiamond (EIP-2535 core storage & cut helpers)\n/// @notice Provides the shared diamond storage layout and internal helpers to add/replace/remove selectors.\n/// @dev All functions here must be called via facets executing in the diamond context (delegatecall).\nlibrary LibDiamond {\n    // 32 bytes keccak hash of a string to use as a diamond storage location.\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    /// @notice Selector\u2192facet address mapping payload.\n    /// @dev `functionSelectorPosition` indexes into the facet\u2019s selectors array.\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition;\n    }\n\n    /// @notice Per-facet selector set and its position in `facetAddresses`.\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition;\n    }\n\n    /// @notice Full diamond storage layout.\n    /// @dev All facets share this storage via delegatecall.\n    struct DiamondStorage {\n        /// selector \u2192 (facet, pos in that facet's selector array)\n        mapping(bytes4 selector => FacetAddressAndPosition facetInfo) selectorToFacetAndPosition;\n        /// facet address \u2192 its selectors + its index in `facetAddresses`\n        mapping(address facetAddress => FacetFunctionSelectors selectors) facetFunctionSelectors;\n        /// list of facet addresses\n        address[] facetAddresses;\n        /// ERC-165 support flags (incl. DiamondCut, Loupe, ERC-173, etc.)\n        mapping(bytes4 interfaceId => bool isSupported) supportedInterfaces;\n        /// ownership (two-step transfer supported via `pendingContractOwner`)\n        address contractOwner;\n        address pendingContractOwner;\n        /// emergency pause: when true, critical marketplace functions are disabled\n        bool paused;\n        // 7 bytes padding for future small variables\n        /// versioning: current diamond version string (e.g., \"1.0.0\", \"1.1.0\")\n        string currentVersion;\n        /// versioning: cryptographic hash of current diamond configuration (facets + selectors)\n        bytes32 currentImplementationId;\n        /// versioning: timestamp when current version was set\n        uint256 currentVersionTimestamp;\n        /// versioning: previous diamond version string (before last upgrade)\n        string previousVersion;\n        /// versioning: previous implementation ID (before last upgrade)\n        bytes32 previousImplementationId;\n        /// versioning: timestamp when previous version was set\n        uint256 previousVersionTimestamp;\n    }\n\n    /// @notice Returns a pointer to diamond storage at the canonical slot.\n    /// @dev Inline assembly assigns the slot to the returned storage reference.\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice Emitted when ownership changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Sets a new contract owner and emits `OwnershipTransferred`.\n    /// @dev No authorization check here; callers should gate with `enforceIsContractOwner`.\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    /// @notice Returns the current contract owner.\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    /// @notice Reverts unless `msg.sender` is the diamond owner.\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    /// @notice Emitted after a diamond cut is applied.\n    /// @param _diamondCut The set of facet actions performed.\n    /// @param _init Initializer target (executed via delegatecall) or address(0).\n    /// @param _calldata Encoded initializer call data (can be empty).\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    /// @notice Applies a diamond cut and optionally runs an initializer.\n    /// @dev Iterates over cuts; for Add/Replace/Remove dispatches to helpers. Emits `DiamondCut` and\n    /// then calls `initializeDiamondCut(_init, _calldata)`.\n    /// Version tracking is handled by deployment/upgrade scripts after the cut is complete.\n    function diamondCut(IDiamondCutFacet.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata)\n        internal\n    {\n        uint256 cutLen = _diamondCut.length;\n        for (uint256 facetIndex = 0; facetIndex < cutLen;) {\n            IDiamondCutFacet.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCutFacet.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCutFacet.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n            unchecked {\n                facetIndex++;\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    /// @notice Adds selectors to a facet (adding the facet if first selector).\n    /// @dev Reverts if any selector already exists or facet is zero address.\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n\n        uint256 selLen = _functionSelectors.length;\n\n        for (uint256 selectorIndex = 0; selectorIndex < selLen;) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n            unchecked {\n                selectorIndex++;\n            }\n        }\n    }\n\n    /// @notice Replaces existing selectors with implementations from a facet.\n    /// @dev Reverts if facet is zero or attempting to replace with same facet.\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n\n        uint256 selLen = _functionSelectors.length;\n\n        for (uint256 selectorIndex; selectorIndex < selLen;) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n            unchecked {\n                selectorIndex++;\n            }\n        }\n    }\n\n    /// @notice Removes selectors (facet address param must be zero by convention).\n    /// @dev Reverts if `_facetAddress != address(0)`; no-op if selector didn\u2019t exist.\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n\n        uint256 selLen = _functionSelectors.length;\n\n        for (uint256 selectorIndex; selectorIndex < selLen;) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n            unchecked {\n                selectorIndex++;\n            }\n        }\n    }\n\n    /// @notice Registers a new facet address in storage.\n    /// @dev Verifies bytecode presence via `extcodesize`.\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    /// @notice Adds a single selector mapping to a facet.\n    /// @dev Appends selector to the facet\u2019s selector array and records its index.\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress)\n        internal\n    {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    /// @notice Removes a selector mapping; compacts arrays and prunes empty facets.\n    /// @dev Cannot remove immutable (in-diamond) functions; bubbles last item swap-and-pop.\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    /// @notice Executes an optional initializer after a cut.\n    /// @dev Requires `_init` to contain code and delegates `_calldata`. Bubbles revert data if any.\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    /// @notice Ensures `_contract` has bytecode.\n    /// @dev Uses `extcodesize` to guard against EOAs or undeployed addresses.\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    }
  }
}