// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";

// Diamond loupe (subset)
interface IDiamondLoupe {
    struct Facet {
        address facetAddress;
        bytes4[] functionSelectors;
    }

    function facets() external view returns (Facet[] memory facets_);
    function facetAddresses() external view returns (address[] memory facetAddresses_);
    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);
}

// ERC165 + ERC173
interface IERC165 {
    function supportsInterface(bytes4 iid) external view returns (bool);
}

interface IOwnershipFacet {
    function owner() external view returns (address);
}

interface IGetterFacet {
    function getContractOwner() external view returns (address);
    function getWhitelistedCollections() external view returns (address[] memory);
}

contract DiamondHealth is Test {
    // live diamond (Sepolia)
    // Set DIAMOND_ADDRESS to override.
    address diamond;

    bytes4 constant IID_ERC165 = 0x01ffc9a7;
    bytes4 constant IID_ERC173 = 0x7f5828d0; // ownership

    function setUp() public {
        // Run on a Sepolia fork so we inspect live state via RPC:
        // forge test --fork-url $SEPOLIA_RPC_URL -vvv --match-contract DiamondHealth
        string memory url = vm.envString("SEPOLIA_RPC_URL");
        vm.createSelectFork(url);

        diamond = vm.envOr("DIAMOND_ADDRESS", address(0x1107Eb26D47A5bF88E9a9F97cbC7EA38c3E1D7EC));
    }

    function test_DiamondLoupeAndInterfaces() public {
        IDiamondLoupe loupe = IDiamondLoupe(diamond);

        // 1) facets exist and each has selectors
        IDiamondLoupe.Facet[] memory fs = loupe.facets();
        assertTrue(fs.length > 0, "no facets");
        for (uint256 i = 0; i < fs.length; i++) {
            assertTrue(fs[i].facetAddress != address(0), "zero facet");
            assertTrue(fs[i].functionSelectors.length > 0, "no selectors");
        }

        // 2) ERC165 and ERC173 (ownership) are supported (via ERC165)
        (bool ok, bytes memory ret) =
            diamond.staticcall(abi.encodeWithSelector(IERC165.supportsInterface.selector, IID_ERC165));
        assertTrue(ok && ret.length >= 32 && abi.decode(ret, (bool)), "ERC165 not supported");

        (ok, ret) = diamond.staticcall(abi.encodeWithSelector(IERC165.supportsInterface.selector, IID_ERC173));
        // ERC-173 via ERC-165 is optional; don't fail hard but log it
        if (ok && ret.length >= 32 && abi.decode(ret, (bool))) {
            // ok
        }
        else emit log("NOTE: ERC-173 not reported via ERC-165 (acceptable)");
    }

    function test_ContractOwnerMatchesDeploymentLog() public {
        // GetterFacet exposes getContractOwner.
        // NOTE: Ownership can change after deployment; this test is written to be resilient.
        IGetterFacet getter = IGetterFacet(diamond);
        address contractOwner = getter.getContractOwner();

        // If the diamond implements ERC-173, ensure both views of ownership agree.
        (bool ok, bytes memory ret) = diamond.staticcall(abi.encodeWithSelector(IOwnershipFacet.owner.selector));
        if (ok && ret.length >= 32) {
            address erc173Owner = abi.decode(ret, (address));
            assertEq(contractOwner, erc173Owner, "getContractOwner != owner() (ERC-173)");
        } else {
            emit log("NOTE: owner() not available/decodable on diamond (acceptable)");
        }

        // Optional pin: set EXPECTED_DIAMOND_OWNER to assert a specific owner.
        address expected = vm.envOr("EXPECTED_DIAMOND_OWNER", address(0));
        if (expected != address(0)) {
            assertEq(contractOwner, expected, "owner mismatch with EXPECTED_DIAMOND_OWNER");
        } else {
            emit log_named_address("Diamond owner", contractOwner);
        }
    }
}
