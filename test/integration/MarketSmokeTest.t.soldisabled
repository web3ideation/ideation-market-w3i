// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import {Listing} from "../../src/libraries/LibAppStorage.sol";

// ---- Minimal interfaces (matching your live diamond on Louper) ----
// Louper shows these function names/selectors on your diamond at
// 0x8cE90712463c87a6d62941D67C3507D090Ea9d79.
interface IERC721 {
    function ownerOf(uint256 id) external view returns (address);
    function approve(address to, uint256 id) external;
    function getApproved(uint256 id) external view returns (address);
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function setApprovalForAll(address operator, bool approved) external;
    function safeTransferFrom(address from, address to, uint256 id) external;
}

// Diamond loupe (for selector presence checks)
interface IDiamondLoupe {
    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
}

interface IGetterFacet {
    function getNextListingId() external view returns (uint128);
    function isCollectionWhitelisted(address collection) external view returns (bool);
    function isCurrencyAllowed(address currency) external view returns (bool);
    function getListingByListingId(uint128 listingId) external view returns (Listing memory listing);
    function getContractOwner() external view returns (address);
    function isBuyerWhitelisted(uint128 listingId, address buyer) external view returns (bool);
    function isPaused() external view returns (bool);
}

// Errors copied by name so we can tolerate "already set" reverts during setup.
error CurrencyWhitelist__AlreadyAllowed();
error CollectionWhitelist__AlreadyWhitelisted();

// Core market errors we assert on in negative-path tests.
error IdeationMarket__BuyerNotWhitelisted(uint128 listingId, address buyer);
error IdeationMarket__CollectionNotWhitelisted(address tokenAddress);

interface ICollectionWhitelistFacet {
    function addWhitelistedCollection(address tokenAddress) external;
}

interface IBuyerWhitelistFacet {
    function addBuyerWhitelistAddresses(uint128 listingId, address[] calldata buyers) external;
    function removeBuyerWhitelistAddresses(uint128 listingId, address[] calldata buyers) external;
}

interface IIdeationMarketFacet {
    function createListing(
        address tokenAddress,
        uint256 tokenId,
        address erc1155Holder,
        uint256 price,
        address currency,
        address desiredTokenAddress,
        uint256 desiredTokenId,
        uint256 desiredErc1155Quantity,
        uint256 erc1155Quantity,
        bool buyerWhitelistEnabled,
        bool partialBuyEnabled,
        address[] calldata allowedBuyers
    ) external;

    function purchaseListing(
        uint128 listingId,
        uint256 expectedPrice,
        address expectedCurrency,
        uint256 expectedErc1155Quantity,
        address expectedDesiredTokenAddress,
        uint256 expectedDesiredTokenId,
        uint256 expectedDesiredErc1155Quantity,
        uint256 erc1155PurchaseQuantity,
        address desiredErc1155Holder
    ) external payable;

    function cancelListing(uint128 listingId) external;
}

// Minimal 1155 just for fork tests
contract Mock1155 {
    mapping(address => mapping(uint256 => uint256)) public balanceOf;
    mapping(address => mapping(address => bool)) public isApprovedForAll;

    function mint(address to, uint256 id, uint256 amt) external {
        balanceOf[to][id] += amt;
    }

    function setApprovalForAll(address op, bool ok) external {
        isApprovedForAll[msg.sender][op] = ok;
    }

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata /*data*/ )
        external
    {
        require(from == msg.sender || isApprovedForAll[from][msg.sender], "not-approved");
        uint256 bal = balanceOf[from][id];
        require(bal >= amount, "insufficient");
        unchecked {
            balanceOf[from][id] = bal - amount;
        }
        balanceOf[to][id] += amount;
    }

    function supportsInterface(bytes4 iid) external pure returns (bool) {
        return iid == 0x01ffc9a7 || iid == 0xd9b67a26;
    }
}

contract MarketSmoke is Test {
    // ---- Live addresses (from your README + deployment log) ----
    // Set DIAMOND_ADDRESS to override.
    address diamond;
    address constant TOKEN721 = 0x41655AE49482de69eEC8F6875c34A8Ada01965e2;

    // Funded EOAs you provided
    address constant ACCOUNT1 = 0xE8dF60a93b2B328397a8CBf73f0d732aaa11e33D; // owns tokenId 16
    address constant ACCOUNT2 = 0x8a200122f666af83aF2D4f425aC7A35fa5491ca7; // owns tokenId 534

    // Tokens you provided
    uint256 constant TOKEN1 = 16; // ERC-721 owned by ACCOUNT1
    uint256 constant TOKEN2 = 534; // ERC-721 owned by ACCOUNT2

    // Prices (wei). For 1155, treat PRICE1155 as unit price.
    uint256 constant PRICE1 = 200_000_000_000_000; // 0.0002 ETH
    uint256 constant PRICE2 = 300_000_000_000_000; // 0.0003 ETH
    uint256 constant PRICE1155 = 50_000_000_000_000; // 0.00005 ETH

    // 1155 params for partial
    uint256 constant ID1155 = 555;
    uint256 constant QTY1155 = 10;
    uint256 constant PARTIAL1 = 3;
    uint256 constant PARTIAL2 = 7;

    IGetterFacet getter;
    IIdeationMarketFacet market;
    ICollectionWhitelistFacet cwl;
    IERC721 erc721 = IERC721(TOKEN721);

    function setUp() public {
        // Run on a Sepolia *fork* tied to live state:
        // forge test --fork-url $SEPOLIA_RPC_URL -vvv --match-contract MarketSmoke
        string memory url = vm.envString("SEPOLIA_RPC_URL");
        vm.createSelectFork(url);

        diamond = vm.envOr("DIAMOND_ADDRESS", address(0x1107Eb26D47A5bF88E9a9F97cbC7EA38c3E1D7EC));
        getter = IGetterFacet(diamond);
        market = IIdeationMarketFacet(diamond);
        cwl = ICollectionWhitelistFacet(diamond);

        emit log_named_uint("fork chainid", block.chainid);
        emit log_named_uint("fork block", block.number);
        emit log_named_address("diamond", diamond);

        // Discover current on-chain diamond owner (can change post-deploy).
        address diamondOwner = _diamondOwner();
        require(diamondOwner != address(0), "cannot determine diamond owner");

        // If paused, createListing/purchaseListing should revert; fail early with a clear reason.
        require(!getter.isPaused(), "diamond is paused");

        // fund local fork accounts for gas
        vm.deal(ACCOUNT1, 10 ether);
        vm.deal(ACCOUNT2, 10 ether);

        // sanity: the two ERC-721s are where you said they are on Sepolia
        assertEq(erc721.ownerOf(TOKEN1), ACCOUNT1, "token 16 not at ACCOUNT1");
        assertEq(erc721.ownerOf(TOKEN2), ACCOUNT2, "token 534 not at ACCOUNT2");

        // Preflight: ensure the live diamond actually has the selectors this test expects.
        // If this fails, your Sepolia deployment likely doesn't include the expected IdeationMarketFacet version.
        IDiamondLoupe loupe = IDiamondLoupe(diamond);

        bytes4 createSel = IIdeationMarketFacet.createListing.selector;
        address createFacet = loupe.facetAddress(createSel);
        emit log_named_uint("createListing selector (uint32)", uint256(uint32(createSel)));
        emit log_named_address("createListing facet", createFacet);
        require(createFacet != address(0), "diamond missing createListing(selector)");

        bytes4 purchaseSel = IIdeationMarketFacet.purchaseListing.selector;
        address purchaseFacet = loupe.facetAddress(purchaseSel);
        emit log_named_uint("purchaseListing selector (uint32)", uint256(uint32(purchaseSel)));
        emit log_named_address("purchaseListing facet", purchaseFacet);
        require(purchaseFacet != address(0), "diamond missing purchaseListing(selector)");

        bytes4 cancelSel = IIdeationMarketFacet.cancelListing.selector;
        address cancelFacet = loupe.facetAddress(cancelSel);
        emit log_named_uint("cancelListing selector (uint32)", uint256(uint32(cancelSel)));
        emit log_named_address("cancelListing facet", cancelFacet);
        require(cancelFacet != address(0), "diamond missing cancelListing(selector)");

        // Also ensure admin/setup selectors exist (so a pass can't be explained by "already whitelisted" state).
        bytes4 addAllowedCurrencySel = bytes4(keccak256("addAllowedCurrency(address)"));
        address currencyFacet = loupe.facetAddress(addAllowedCurrencySel);
        emit log_named_address("addAllowedCurrency facet", currencyFacet);
        require(currencyFacet != address(0), "diamond missing addAllowedCurrency(selector)");

        bytes4 addWhitelistedCollectionSel = bytes4(keccak256("addWhitelistedCollection(address)"));
        address collectionFacet = loupe.facetAddress(addWhitelistedCollectionSel);
        emit log_named_address("addWhitelistedCollection facet", collectionFacet);
        require(collectionFacet != address(0), "diamond missing addWhitelistedCollection(selector)");

        // Ensure ETH is allowed as currency for listings.
        // If it's already allowed, keep setup idempotent; otherwise require the admin call succeeds.
        if (!getter.isCurrencyAllowed(address(0))) {
            vm.startPrank(diamondOwner);
            {
                (bool success, bytes memory ret) =
                    diamond.call(abi.encodeWithSignature("addAllowedCurrency(address)", address(0)));
                if (!success) {
                    bytes4 sel = ret.length >= 4 ? bytes4(ret) : bytes4(0);
                    // If state said "not allowed" but we got "AlreadyAllowed", accept and continue.
                    if (sel != CurrencyWhitelist__AlreadyAllowed.selector) {
                        revert("failed to allowlist ETH");
                    }
                }
            }
            vm.stopPrank();

            assertTrue(getter.isCurrencyAllowed(address(0)), "ETH still not allowed");
        }

        // Ensure the 721 collection is whitelisted.
        if (!getter.isCollectionWhitelisted(TOKEN721)) {
            vm.startPrank(diamondOwner);
            {
                (bool success, bytes memory ret) =
                    diamond.call(abi.encodeWithSignature("addWhitelistedCollection(address)", TOKEN721));
                if (!success) {
                    bytes4 sel = ret.length >= 4 ? bytes4(ret) : bytes4(0);
                    if (sel != CollectionWhitelist__AlreadyWhitelisted.selector) {
                        revert("failed to whitelist TOKEN721");
                    }
                }
            }
            vm.stopPrank();

            assertTrue(getter.isCollectionWhitelisted(TOKEN721), "TOKEN721 still not whitelisted");
        }
    }

    // 721 list -> buy -> cleanup (A1 sells to A2; then A2 transfers back)
    function test_A_ERC721_ListBuyCleanup() public {
        _approve721IfNeeded(ACCOUNT1, TOKEN1);

        uint128 id = getter.getNextListingId();

        vm.startPrank(ACCOUNT1);
        {
            market.createListing(
                TOKEN721,
                TOKEN1,
                address(0), // erc1155Holder not used for 721
                PRICE1,
                address(0), // currency: ETH
                address(0),
                0,
                0,
                0, // erc1155Quantity == 0 => 721 listing
                false, // whitelist OFF
                false, // partial OFF
                new address[](0)
            );
        }
        vm.stopPrank();

        vm.prank(ACCOUNT2);
        market.purchaseListing{value: PRICE1}(id, PRICE1, address(0), 0, address(0), 0, 0, 0, address(0));

        assertEq(erc721.ownerOf(TOKEN1), ACCOUNT2, "buyer did not receive 721");

        // cleanup: transfer back so test is re-runnable even on live if mirrored
        vm.startPrank(ACCOUNT2);
        erc721.safeTransferFrom(ACCOUNT2, ACCOUNT1, TOKEN1);
        vm.stopPrank();

        assertEq(erc721.ownerOf(TOKEN1), ACCOUNT1, "cleanup transfer back failed");
    }

    // 721 list -> cancel (A2)
    function test_B_ERC721_ListCancel() public {
        _approve721IfNeeded(ACCOUNT2, TOKEN2);

        uint128 id = getter.getNextListingId();

        vm.startPrank(ACCOUNT2);
        {
            market.createListing(
                TOKEN721, TOKEN2, address(0), PRICE2, address(0), address(0), 0, 0, 0, false, false, new address[](0)
            );
        }
        vm.stopPrank();

        vm.prank(ACCOUNT2);
        market.cancelListing(id);

        assertEq(erc721.ownerOf(TOKEN2), ACCOUNT2, "cancel did not restore owner");
    }

    // 721 whitelist: positive (ACCOUNT2 allowed)
    function test_C_ERC721_Whitelist_Positive() public {
        _approve721IfNeeded(ACCOUNT1, TOKEN1);

        uint128 id = getter.getNextListingId();

        vm.startPrank(ACCOUNT1);
        {
            address[] memory allowed = new address[](1);
            allowed[0] = ACCOUNT2;
            market.createListing(
                TOKEN721,
                TOKEN1,
                address(0),
                PRICE1,
                address(0), // currency: ETH
                address(0),
                0,
                0,
                0,
                true, // whitelist ON
                false,
                allowed
            );
        }
        vm.stopPrank();

        // Ensure the whitelist actually got applied.
        assertTrue(getter.isBuyerWhitelisted(id, ACCOUNT2), "ACCOUNT2 not whitelisted");

        vm.prank(ACCOUNT2);
        market.purchaseListing{value: PRICE1}(id, PRICE1, address(0), 0, address(0), 0, 0, 0, address(0));

        // cleanup
        vm.startPrank(ACCOUNT2);
        erc721.safeTransferFrom(ACCOUNT2, ACCOUNT1, TOKEN1);
        vm.stopPrank();

        assertEq(erc721.ownerOf(TOKEN1), ACCOUNT1, "whitelist+cleanup failed");
    }

    // 721 whitelist: negative (ACCOUNT2 NOT allowed) → expect revert → seller cancels
    function test_D_ERC721_Whitelist_Negative() public {
        _approve721IfNeeded(ACCOUNT1, TOKEN1);

        uint128 id = getter.getNextListingId();

        vm.startPrank(ACCOUNT1);
        {
            address[] memory allowed = new address[](1);
            allowed[0] = ACCOUNT1; // deliberately exclude ACCOUNT2
            market.createListing(
                TOKEN721,
                TOKEN1,
                address(0),
                PRICE1,
                address(0), // currency: ETH
                address(0),
                0,
                0,
                0,
                true, // whitelist ON
                false,
                allowed
            );
        }
        vm.stopPrank();

        // Ensure whitelist is enabled and ACCOUNT2 is not included.
        assertTrue(getter.isBuyerWhitelisted(id, ACCOUNT1), "ACCOUNT1 not whitelisted");
        assertTrue(!getter.isBuyerWhitelisted(id, ACCOUNT2), "ACCOUNT2 unexpectedly whitelisted");

        vm.prank(ACCOUNT2);
        vm.expectRevert(abi.encodeWithSelector(IdeationMarket__BuyerNotWhitelisted.selector, id, ACCOUNT2));
        market.purchaseListing{value: PRICE1}(id, PRICE1, address(0), 0, address(0), 0, 0, 0, address(0));

        // cleanup
        vm.prank(ACCOUNT1);
        market.cancelListing(id);

        assertEq(erc721.ownerOf(TOKEN1), ACCOUNT1, "owner changed unexpectedly");
    }

    // 1155 partial: create (seller A1) → buy 3 + buy 7 (A2) → cleanup: return all
    function test_E_ERC1155_PartialAndFill() public {
        // deploy a local mock 1155 and whitelist it
        Mock1155 token1155 = new Mock1155();

        address diamondOwner = _diamondOwner();

        // Best-effort: whitelist the mock 1155.
        assertTrue(!getter.isCollectionWhitelisted(address(token1155)), "mock1155 unexpectedly pre-whitelisted");
        vm.startPrank(diamondOwner);
        {
            (bool success, bytes memory ret) =
                diamond.call(abi.encodeWithSignature("addWhitelistedCollection(address)", address(token1155)));
            if (!success) {
                bytes4 sel = ret.length >= 4 ? bytes4(ret) : bytes4(0);
                if (sel != CollectionWhitelist__AlreadyWhitelisted.selector) {
                    revert("failed to whitelist mock1155");
                }
            }
        }
        vm.stopPrank();
        assertTrue(getter.isCollectionWhitelisted(address(token1155)), "mock1155 still not whitelisted");

        // mint to seller and approve marketplace
        vm.startPrank(ACCOUNT1);
        token1155.mint(ACCOUNT1, ID1155, QTY1155);
        token1155.setApprovalForAll(diamond, true);
        vm.stopPrank();

        // create listing with partial ON
        uint128 id = getter.getNextListingId();

        vm.startPrank(ACCOUNT1);
        {
            market.createListing(
                address(token1155),
                ID1155,
                ACCOUNT1, // erc1155Holder
                PRICE1155 * QTY1155, // Total Listing price at creation
                address(0), // currency: ETH
                address(0),
                0,
                0,
                QTY1155, // > 0 => 1155
                false, // whitelist OFF
                true, // partial ON
                new address[](0)
            );
        }
        vm.stopPrank();

        // Buyer takes partials 3 then 7 (total 10)
        vm.prank(ACCOUNT2);
        market.purchaseListing{value: PRICE1155 * PARTIAL1}(
            id, PRICE1155 * QTY1155, address(0), QTY1155, address(0), 0, 0, PARTIAL1, ACCOUNT2
        );

        // Buyer partial #2 (use UPDATED remaining terms)
        uint256 remainingQty = QTY1155 - PARTIAL1;
        uint256 remainingTotal = (PRICE1155 * QTY1155) - (PRICE1155 * PARTIAL1);

        // Verify listing state was updated correctly after partial buy.
        {
            Listing memory l = getter.getListingByListingId(id);
            assertEq(l.erc1155Quantity, remainingQty, "remaining qty mismatch");
            assertEq(l.price, remainingTotal, "remaining total mismatch");
        }

        vm.prank(ACCOUNT2);
        market.purchaseListing{value: PRICE1155 * PARTIAL2}(
            id, remainingTotal, address(0), remainingQty, address(0), 0, 0, PARTIAL2, ACCOUNT2
        );

        // Listing should now be fully bought and removed.
        vm.expectRevert();
        getter.getListingByListingId(id);

        // assertion + cleanup (return to seller)
        assertEq(token1155.balanceOf(ACCOUNT2, ID1155), QTY1155, "buyer 1155 qty mismatch");

        vm.startPrank(ACCOUNT2);
        token1155.safeTransferFrom(ACCOUNT2, ACCOUNT1, ID1155, QTY1155, "");
        vm.stopPrank();

        assertEq(token1155.balanceOf(ACCOUNT1, ID1155), QTY1155, "cleanup return failed");
    }

    // Collection whitelist must gate createListing (defense-in-depth smoke check).
    function test_F_CreateListing_RevertsWhenCollectionNotWhitelisted() public {
        // We use a random address (no code) because createListing must revert on whitelist *before*
        // interacting with the token contract.
        address notWhitelistedToken = address(0xDeaD);

        vm.startPrank(ACCOUNT1);
        vm.expectRevert(abi.encodeWithSelector(IdeationMarket__CollectionNotWhitelisted.selector, notWhitelistedToken));
        market.createListing(
            notWhitelistedToken, 1, address(0), 1, address(0), address(0), 0, 0, 0, false, false, new address[](0)
        );
        vm.stopPrank();
    }

    // --- helpers ---
    function _approve721IfNeeded(address owner, uint256 tokenId) internal {
        vm.startPrank(owner);
        if (erc721.getApproved(tokenId) != diamond && !erc721.isApprovedForAll(owner, diamond)) {
            erc721.approve(diamond, tokenId);
        }
        vm.stopPrank();
    }

    function _diamondOwner() internal view returns (address owner_) {
        (bool ok, bytes memory ret) = diamond.staticcall(abi.encodeWithSignature("getContractOwner()"));
        if (ok && ret.length >= 32) return abi.decode(ret, (address));

        (ok, ret) = diamond.staticcall(abi.encodeWithSignature("owner()"));
        if (ok && ret.length >= 32) return abi.decode(ret, (address));

        // If neither getter exists, something is very wrong with the deployment.
        return address(0);
    }
}
